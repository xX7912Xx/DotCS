package nbt

import (
	"bytes"
	"compress/gzip"
	"io"
	"math"
	"reflect"
	"testing"
)

func TestUnmarshal_string(t *testing.T) {
	var data = []byte{
		0x08, 0x00, 0x04, 0x6e, 0x61, 0x6d, 0x65, 0x00, 0x09,
		0x42, 0x61, 0x6e, 0x61, 0x6e, 0x72, 0x61, 0x6d, 0x61,
	}

	//Unmarshal to string
	var Name string
	if err := Unmarshal(data, &Name); err != nil {
		t.Fatal(err)
	}

	if Name != "Bananrama" {
		t.Errorf("Unmarshal NBT fail: get %q, want %q", Name, "Bananrama")
	}

	//Unmarshal to interface{}
	var infName interface{}
	if err := Unmarshal(data, &infName); err != nil {
		t.Fatal(err)
	}

	if infName != "Bananrama" {
		t.Errorf("Unmarshal NBT fail: get %q, want %q", Name, "Bananrama")
	}
}

func TestUnmarshal_simple(t *testing.T) {
	var data = []byte{
		0x0a, 0x00, 0x0b, 0x68, 0x65, 0x6c, 0x6c, 0x6f,
		0x20, 0x77, 0x6f, 0x72, 0x6c, 0x64, 0x08, 0x00,
		0x04, 0x6e, 0x61, 0x6d, 0x65, 0x00, 0x09, 0x42,
		0x61, 0x6e, 0x61, 0x6e, 0x72, 0x61, 0x6d, 0x61,
		0x00,
	}

	//test parse
	var value struct {
		Name string `nbt:"name"`
	}
	if err := Unmarshal(data, &value); err != nil {
		t.Fatal(err)
	}
	if value.Name != "Bananrama" {
		t.Errorf("Unmarshal NBT fail: get %q, want %q", value.Name, "Bananrama")
	}

	//test rawRead
	var empty struct{}
	if err := Unmarshal(data, &empty); err != nil {
		t.Fatal(err)
	}
}

// Generated by vscode-hexdump
var bigTestData = [...]byte{
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0xed, 0x54, 0xcf, 0x4f, 0x1a, 0x41,
	0x14, 0x7e, 0xc2, 0x02, 0xcb, 0x96, 0x82, 0xb1,
	0xc4, 0x10, 0x63, 0xcc, 0xab, 0xb5, 0x84, 0xa5,
	0xdb, 0xcd, 0x42, 0x11, 0x89, 0xb1, 0x88, 0x16,
	0x2c, 0x9a, 0x0d, 0x1a, 0xd8, 0xa8, 0x31, 0x86,
	0xb8, 0x2b, 0xc3, 0x82, 0x2e, 0xbb, 0x66, 0x77,
	0xb0, 0xf1, 0xd4, 0x4b, 0x7b, 0x6c, 0x7a, 0xeb,
	0x3f, 0xd3, 0x23, 0x7f, 0x43, 0xcf, 0xbd, 0xf6,
	0xbf, 0xa0, 0xc3, 0x2f, 0x7b, 0x69, 0xcf, 0xbd,
	0xf0, 0x32, 0xc9, 0xf7, 0xe6, 0xbd, 0x6f, 0xe6,
	0x7b, 0x6f, 0x26, 0x79, 0x02, 0x04, 0x54, 0x72,
	0x4f, 0x2c, 0x0e, 0x78, 0xcb, 0xb1, 0x4d, 0x8d,
	0x78, 0xf4, 0xe3, 0x70, 0x62, 0x3e, 0x08, 0x7b,
	0x1d, 0xc7, 0xa5, 0x93, 0x18, 0x0f, 0x82, 0x47,
	0xdd, 0xee, 0x84, 0x02, 0x62, 0xb5, 0xa2, 0xaa,
	0xc7, 0x78, 0x76, 0x5c, 0x57, 0xcb, 0xa8, 0x55,
	0x0f, 0x1b, 0xc8, 0xd6, 0x1e, 0x6a, 0x95, 0x86,
	0x86, 0x0d, 0xad, 0x7e, 0x58, 0x7b, 0x8f, 0x83,
	0xcf, 0x83, 0x4f, 0x83, 0x6f, 0xcf, 0x03, 0x10,
	0x6e, 0x5b, 0x8e, 0x3e, 0xbe, 0xa5, 0x38, 0x4c,
	0x64, 0xfd, 0x10, 0xea, 0xda, 0x74, 0xa6, 0x23,
	0x40, 0xdc, 0x66, 0x2e, 0x69, 0xe1, 0xb5, 0xd3,
	0xbb, 0x73, 0xfa, 0x76, 0x0b, 0x29, 0xdb, 0x0b,
	0xe0, 0xef, 0xe8, 0x3d, 0x1e, 0x38, 0x5b, 0xef,
	0x11, 0x08, 0x56, 0xf5, 0xde, 0x5d, 0xdf, 0x0b,
	0x40, 0xe0, 0x5e, 0xb7, 0xfa, 0x64, 0xb7, 0x04,
	0x00, 0x8c, 0x41, 0x4c, 0x73, 0xc6, 0x08, 0x55,
	0x4c, 0xd3, 0x20, 0x2e, 0x7d, 0xa4, 0xc0, 0xc8,
	0xc2, 0x10, 0xb3, 0xba, 0xde, 0x58, 0x0b, 0x53,
	0xa3, 0xee, 0x44, 0x8e, 0x45, 0x03, 0x30, 0xb1,
	0x27, 0x53, 0x8c, 0x4c, 0xf1, 0xe9, 0x14, 0xa3,
	0x53, 0x8c, 0x85, 0xe1, 0xd9, 0x9f, 0xe3, 0xb3,
	0xf2, 0x44, 0x81, 0xa5, 0x7c, 0x33, 0xdd, 0xd8,
	0xbb, 0xc7, 0xaa, 0x75, 0x13, 0x5f, 0x28, 0x1c,
	0x08, 0xd7, 0x2e, 0xd1, 0x59, 0x3f, 0xaf, 0x1d,
	0x1b, 0x60, 0x21, 0x59, 0xdf, 0xfa, 0xf1, 0x05,
	0xfe, 0xc1, 0xce, 0xfc, 0x9d, 0xbd, 0x00, 0xbc,
	0xf1, 0x40, 0xc9, 0xf8, 0x85, 0x42, 0x40, 0x46,
	0xfe, 0x9e, 0xeb, 0xea, 0x0f, 0x93, 0x3a, 0x68,
	0x87, 0x60, 0xbb, 0xeb, 0x32, 0x37, 0xa3, 0x28,
	0x0a, 0x8e, 0xbb, 0xf5, 0xd0, 0x69, 0x63, 0xca,
	0x4e, 0xdb, 0xe9, 0xec, 0xe6, 0xe6, 0x2b, 0x3b,
	0xbd, 0x25, 0xbe, 0x64, 0x49, 0x09, 0x3d, 0xaa,
	0xbb, 0x94, 0xfd, 0x18, 0x7e, 0xe8, 0xd2, 0x0e,
	0xda, 0x6f, 0x15, 0x4c, 0xb1, 0x68, 0x3e, 0x2b,
	0xe1, 0x9b, 0x9c, 0x84, 0x99, 0xbc, 0x84, 0x05,
	0x09, 0x65, 0x59, 0x16, 0x45, 0x00, 0xff, 0x2f,
	0x28, 0xae, 0x2f, 0xf2, 0xc2, 0xb2, 0xa4, 0x2e,
	0x1d, 0x20, 0x77, 0x5a, 0x3b, 0xb9, 0x8c, 0xca,
	0xe7, 0x29, 0xdf, 0x51, 0x41, 0xc9, 0x16, 0xb5,
	0xc5, 0x6d, 0xa1, 0x2a, 0xad, 0x2c, 0xc5, 0x31,
	0x7f, 0xba, 0x7a, 0x92, 0x8e, 0x5e, 0x9d, 0x5f,
	0xf8, 0x12, 0x05, 0x23, 0x1b, 0xd1, 0xf6, 0xb7,
	0x77, 0xaa, 0xcd, 0x95, 0x72, 0xbc, 0x9e, 0xdf,
	0x58, 0x5d, 0x4b, 0x97, 0xae, 0x92, 0x17, 0xb9,
	0x44, 0xd0, 0x80, 0xc8, 0xfa, 0x3e, 0xbf, 0xb3,
	0xdc, 0x54, 0xcb, 0x07, 0x75, 0x6e, 0xa3, 0xb6,
	0x76, 0x59, 0x92, 0x93, 0xa9, 0xdc, 0x51, 0x50,
	0x99, 0x6b, 0xcc, 0x35, 0xe6, 0x1a, 0xff, 0x57,
	0x23, 0x08, 0x42, 0xcb, 0xe9, 0x1b, 0xd6, 0x78,
	0xc2, 0xec, 0xfe, 0xfc, 0x7a, 0xfb, 0x7d, 0x78,
	0xd3, 0x84, 0xdf, 0xd4, 0xf2, 0xa4, 0xfb, 0x08,
	0x06, 0x00, 0x00,
}

type BigTestStruct struct {
	LongTest   int64   `nbt:"longTest"`
	ShortTest  int16   `nbt:"shortTest"`
	StringTest string  `nbt:"stringTest"`
	FloatTest  float32 `nbt:"floatTest"`
	IntTest    int32   `nbt:"intTest"`
	NCT        struct {
		Ham struct {
			Name  string  `nbt:"name"`
			Value float32 `nbt:"value"`
		} `nbt:"ham"`
		Egg struct {
			Name  string  `nbt:"name"`
			Value float32 `nbt:"value"`
		} `nbt:"egg"`
	} `nbt:"nested compound test"`
	ListTest  []int64 `nbt:"listTest (long)" nbt_type:"list"`
	ListTest2 [2]struct {
		Name      string `nbt:"name"`
		CreatedOn int64  `nbt:"created-on"`
	} `nbt:"listTest (compound)"`
	ByteTest      byte    `nbt:"byteTest"`
	ByteArrayTest []byte  `nbt:"byteArrayTest (the first 1000 values of (n*n*255+n*7)%100, starting with n=0 (0, 62, 34, 16, 8, ...))"`
	DoubleTest    float64 `nbt:"doubleTest"`
}

func MakeBigTestStruct() BigTestStruct {
	var want BigTestStruct
	want.NCT.Egg.Name = "Eggbert"
	want.NCT.Egg.Value = 0.5
	want.NCT.Ham.Name = "Hampus"
	want.NCT.Ham.Value = 0.75
	want.IntTest = 2147483647
	want.ByteTest = 127
	want.StringTest = "HELLO WORLD THIS IS A TEST STRING \xc3\x85\xc3\x84\xc3\x96!"
	want.ListTest = []int64{11, 12, 13, 14, 15}
	want.DoubleTest = 0.49312871321823148
	want.FloatTest = 0.49823147058486938
	want.LongTest = 9223372036854775807
	want.ListTest2[0].CreatedOn = 1264099775885
	want.ListTest2[0].Name = "Compound tag #0"
	want.ListTest2[1].CreatedOn = 1264099775885
	want.ListTest2[1].Name = "Compound tag #1"
	want.ByteArrayTest = make([]byte, 1000)
	for n := 0; n < 1000; n++ {
		want.ByteArrayTest[n] = byte((n*n*255 + n*7) % 100)
	}
	want.ShortTest = 32767
	return want
}

func TestDecoder_Decode_bigTest(t *testing.T) {
	//test parse
	var value BigTestStruct
	r, err := gzip.NewReader(bytes.NewReader(bigTestData[:]))
	if err != nil {
		t.Fatal(err)
	}
	if _, err := NewDecoder(r).Decode(&value); err != nil {
		t.Fatal(err)
	}

	want := MakeBigTestStruct()
	if !reflect.DeepEqual(value, want) {
		t.Errorf("parse fail, expect %v, get %v", want, value)
	}

	//test rawRead
	var empty struct{}
	r, err = gzip.NewReader(bytes.NewReader(bigTestData[:]))
	if err != nil {
		t.Fatal(err)
	}
	if _, err := NewDecoder(r).Decode(&empty); err != nil {
		t.Fatal(err)
	}

	var inf interface{}
	r, err = gzip.NewReader(bytes.NewReader(bigTestData[:]))
	if err != nil {
		t.Fatal(err)
	}
	if _, err := NewDecoder(r).Decode(&inf); err != nil {
		t.Fatal(err)
	}
	// t.Log(inf)
}

func BenchmarkDecoder_Decode_bigTest(b *testing.B) {
	var value BigTestStruct
	for i := 0; i < b.N; i++ {
		r, err := gzip.NewReader(bytes.NewReader(bigTestData[:]))
		if err != nil {
			b.Fatal(err)
		}
		if _, err := NewDecoder(r).Decode(&value); err != nil {
			b.Fatal(err)
		}
	}

	want := MakeBigTestStruct()
	if !reflect.DeepEqual(value, want) {
		b.Errorf("parse fail, expect %v, get %v", want, value)
	}
}

func TestDecoder_overRead(t *testing.T) {
	const tail = 16
	// Uncompressed NBT
	enc := []byte{
		TagCompound, 0, 1, 'A',
		TagString, 0, 1, 'B', 0, 0,
		TagEnd,
	}
	dataLen := len(enc)
	// these zeros are honeypot, we should not read them
	enc = append(enc, make([]byte, tail)...)

	var value struct {
		B string
	}

	r := bytes.NewReader(enc)
	// Count read bytes by using io.LimitReader
	rr := io.LimitReader(r, math.MaxInt64).(*io.LimitedReader)
	if _, err := NewDecoder(rr).Decode(&value); err != nil {
		t.Fatal(err)
	}

	readBytesNum := math.MaxInt64 - rr.N
	if readBytesNum > int64(dataLen) || r.Len() < tail {
		t.Errorf("Over read! nbt length: %d, but you read %d", dataLen, readBytesNum)
	}
}

func TestDecoder_Decode_IntArray(t *testing.T) {
	data := []byte{
		TagIntArray, 0, 0,
		0, 0, 0, 3,

		0, 0, 0, 1,
		0, 0, 0, 2,
		0, 0, 0, 3,
	}
	var (
		value []int
		want  = []int{1, 2, 3}

		value2 []int32
		want2  = []int32{1, 2, 3}
	)

	if err := Unmarshal(data, &value); err != nil {
		t.Fatal(err)
	}
	if !reflect.DeepEqual(value, want) {
		t.Errorf("parse fail, expect %v, get %v", want, value)
	}

	if err := Unmarshal(data, &value2); err != nil {
		t.Fatal(err)
	}
	if !reflect.DeepEqual(value2, want2) {
		t.Errorf("parse fail, expect %v, get %v", want2, value2)
	}

	// t.Log(value, value2)
}

func TestDecoder_Decode_LongArray(t *testing.T) {
	data := []byte{
		TagLongArray, 0, 0,
		0, 0, 0, 3,

		0, 0, 0, 0, 0, 0, 0, 1,
		0, 0, 0, 0, 0, 0, 0, 2,
		0, 0, 0, 0, 0, 0, 0, 3,
	}
	var (
		value    []int64
		infValue interface{}
		want     = []int64{1, 2, 3}
	)

	if err := Unmarshal(data, &value); err != nil {
		t.Fatal(err)
	}
	if !reflect.DeepEqual(value, want) {
		t.Errorf("parse fail, expect %v, get %v", want, value)
	}
	// t.Log(value)

	if err := Unmarshal(data, &infValue); err != nil {
		t.Fatal(err)
	}
	if !reflect.DeepEqual(infValue, want) {
		t.Errorf("parse fail, expect %v, get %v", want, infValue)
	}
	// t.Log(infValue)
}

func TestDecoder_Decode_ByteArray(t *testing.T) {
	data := []byte{
		TagByteArray, 0, 0,
		0, 0, 0, 7,
		0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
	}
	var (
		value    []byte
		infValue interface{}
		want     = []byte{0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07}
	)

	//Unmarshal to []byte
	if err := Unmarshal(data, &value); err != nil {
		t.Fatal(err)
	}
	if !reflect.DeepEqual(value, want) {
		t.Errorf("parse fail, expect %v, get %v", want, value)
	}
	// t.Log(value)

	//Unmarshal to interface{}
	if err := Unmarshal(data, &infValue); err != nil {
		t.Fatal(err)
	}
	if !reflect.DeepEqual(infValue, want) {
		t.Errorf("parse fail, expect %v, get %v", want, value)
	}
	// t.Log(infValue)
}

func TestDecoder_Decode_ErrorString(t *testing.T) {
	var data = []byte{
		0x08, 0x00, 0x04, 0x6e, 0x61, 0x6d, 0x65, 0xFF, 0xFE,
		0x42, 0x61, 0x6e, 0x61, 0x6e, 0x72, 0x61, 0x6d, 0x61,
	}

	//Unmarshal to string
	var Name string
	err := Unmarshal(data, &Name)

	if err == nil {
		t.Error("should return a error if len < 0")
	}
	t.Log(err)

}

func TestRawMessage_Decode(t *testing.T) {
	data := []byte{
		TagCompound, 0, 2, 'a', 'b',
		TagInt, 0, 3, 'K', 'e', 'y', 0, 0, 0, 12,
		TagString, 0, 5, 'V', 'a', 'l', 'u', 'e', 0, 4, 'T', 'n', 'z', 'e',
		TagList, 0, 4, 'L', 'i', 's', 't', TagCompound, 0, 0, 0, 2, 0, 0,
		TagEnd,
	}
	var container struct {
		Key   int32
		Value RawMessage
		List  RawMessage
	}

	if tag, err := NewDecoder(bytes.NewReader(data)).Decode(&container); err != nil {
		t.Fatal(tag)
	} else {
		if tag != "ab" {
			t.Fatalf("Decode tag name error: want %s, get: %s", "ab", tag)
		}
		if container.Key != 12 {
			t.Fatalf("Decode Key error: want %v, get: %v", 12, container.Key)
		}
		if !bytes.Equal(container.Value.Data, []byte{
			0, 4, 'T', 'n', 'z', 'e',
		}) {
			t.Fatalf("Decode Key error: get: %v", container.Value)
		}
		if !bytes.Equal(container.List.Data, []byte{
			TagCompound, 0, 0, 0, 2,
			0, 0,
		}) {
			t.Fatalf("Decode List error: get: %v", container.List)
		}
	}
}

func TestStringifiedMessage_Decode(t *testing.T) {
	data := []byte{
		TagCompound, 0, 2, 'a', 'b',
		TagInt, 0, 3, 'K', 'e', 'y', 0, 0, 0, 12,
		TagString, 0, 5, 'V', 'a', 'l', 'u', 'e', 0, 5, 'T', 'n', ' ', 'z', 'e',
		TagList, 0, 4, 'L', 'i', 's', 't', TagCompound, 0, 0, 0, 2, 0, 0,
		TagEnd,
	}
	var container struct {
		Key   int32
		Value StringifiedMessage
		List  StringifiedMessage
	}

	if tag, err := NewDecoder(bytes.NewReader(data)).Decode(&container); err != nil {
		t.Fatal(tag, err)
	} else {
		if tag != "ab" {
			t.Fatalf("Decode tag name error: want %s, get: %s", "ab", tag)
		}
		if container.Key != 12 {
			t.Fatalf("Decode Key error: want %v, get: %v", 12, container.Key)
		}
		if container.Value != `"Tn ze"` {
			t.Fatalf("Decode Key error: get: %v", container.Value)
		}
		if container.List != "[{},{}]" {
			t.Fatalf("Decode List error: get: %v", container.List)
		}
	}
}

func TestStringifiedMessage_Decode_bigTest(t *testing.T) {
	var snbt StringifiedMessage
	r, err := gzip.NewReader(bytes.NewReader(bigTestData[:]))
	if err != nil {
		t.Fatal(err)
	}
	if tag, err := NewDecoder(r).Decode(&snbt); err != nil {
		t.Fatal(tag, err)
	} else if string(snbt) != `{longTest:9223372036854775807L,shortTest:32767S,stringTest:"HELLO WORLD THIS IS A TEST STRING ÅÄÖ!",floatTest:0.4982314706F,intTest:2147483647I,"nested compound test":{ham:{name:Hampus,value:0.7500000000F},egg:{name:Eggbert,value:0.5000000000F}},"listTest (long)":[11L,12L,13L,14L,15L],"listTest (compound)":[{name:"Compound tag #0",created-on:1264099775885L},{name:"Compound tag #1",created-on:1264099775885L}],byteTest:127B,"byteArrayTest (the first 1000 values of (n*n*255+n*7)%100, starting with n=0 (0, 62, 34, 16, 8, ...))":[B;0B,62B,34B,16B,8B,10B,22B,44B,76B,18B,70B,32B,4B,86B,78B,80B,92B,14B,46B,88B,40B,2B,74B,56B,48B,50B,62B,84B,16B,58B,10B,72B,44B,26B,18B,20B,32B,54B,86B,28B,80B,42B,14B,96B,88B,90B,2B,24B,56B,98B,50B,12B,84B,66B,58B,60B,72B,94B,26B,68B,20B,82B,54B,36B,28B,30B,42B,64B,96B,38B,90B,52B,24B,6B,98B,0B,12B,34B,66B,8B,60B,22B,94B,76B,68B,70B,82B,4B,36B,78B,30B,92B,64B,46B,38B,40B,52B,74B,6B,48B,0B,62B,34B,16B,8B,10B,22B,44B,76B,18B,70B,32B,4B,86B,78B,80B,92B,14B,46B,88B,40B,2B,74B,56B,48B,50B,62B,84B,16B,58B,10B,72B,44B,26B,18B,20B,32B,54B,86B,28B,80B,42B,14B,96B,88B,90B,2B,24B,56B,98B,50B,12B,84B,66B,58B,60B,72B,94B,26B,68B,20B,82B,54B,36B,28B,30B,42B,64B,96B,38B,90B,52B,24B,6B,98B,0B,12B,34B,66B,8B,60B,22B,94B,76B,68B,70B,82B,4B,36B,78B,30B,92B,64B,46B,38B,40B,52B,74B,6B,48B,0B,62B,34B,16B,8B,10B,22B,44B,76B,18B,70B,32B,4B,86B,78B,80B,92B,14B,46B,88B,40B,2B,74B,56B,48B,50B,62B,84B,16B,58B,10B,72B,44B,26B,18B,20B,32B,54B,86B,28B,80B,42B,14B,96B,88B,90B,2B,24B,56B,98B,50B,12B,84B,66B,58B,60B,72B,94B,26B,68B,20B,82B,54B,36B,28B,30B,42B,64B,96B,38B,90B,52B,24B,6B,98B,0B,12B,34B,66B,8B,60B,22B,94B,76B,68B,70B,82B,4B,36B,78B,30B,92B,64B,46B,38B,40B,52B,74B,6B,48B,0B,62B,34B,16B,8B,10B,22B,44B,76B,18B,70B,32B,4B,86B,78B,80B,92B,14B,46B,88B,40B,2B,74B,56B,48B,50B,62B,84B,16B,58B,10B,72B,44B,26B,18B,20B,32B,54B,86B,28B,80B,42B,14B,96B,88B,90B,2B,24B,56B,98B,50B,12B,84B,66B,58B,60B,72B,94B,26B,68B,20B,82B,54B,36B,28B,30B,42B,64B,96B,38B,90B,52B,24B,6B,98B,0B,12B,34B,66B,8B,60B,22B,94B,76B,68B,70B,82B,4B,36B,78B,30B,92B,64B,46B,38B,40B,52B,74B,6B,48B,0B,62B,34B,16B,8B,10B,22B,44B,76B,18B,70B,32B,4B,86B,78B,80B,92B,14B,46B,88B,40B,2B,74B,56B,48B,50B,62B,84B,16B,58B,10B,72B,44B,26B,18B,20B,32B,54B,86B,28B,80B,42B,14B,96B,88B,90B,2B,24B,56B,98B,50B,12B,84B,66B,58B,60B,72B,94B,26B,68B,20B,82B,54B,36B,28B,30B,42B,64B,96B,38B,90B,52B,24B,6B,98B,0B,12B,34B,66B,8B,60B,22B,94B,76B,68B,70B,82B,4B,36B,78B,30B,92B,64B,46B,38B,40B,52B,74B,6B,48B,0B,62B,34B,16B,8B,10B,22B,44B,76B,18B,70B,32B,4B,86B,78B,80B,92B,14B,46B,88B,40B,2B,74B,56B,48B,50B,62B,84B,16B,58B,10B,72B,44B,26B,18B,20B,32B,54B,86B,28B,80B,42B,14B,96B,88B,90B,2B,24B,56B,98B,50B,12B,84B,66B,58B,60B,72B,94B,26B,68B,20B,82B,54B,36B,28B,30B,42B,64B,96B,38B,90B,52B,24B,6B,98B,0B,12B,34B,66B,8B,60B,22B,94B,76B,68B,70B,82B,4B,36B,78B,30B,92B,64B,46B,38B,40B,52B,74B,6B,48B,0B,62B,34B,16B,8B,10B,22B,44B,76B,18B,70B,32B,4B,86B,78B,80B,92B,14B,46B,88B,40B,2B,74B,56B,48B,50B,62B,84B,16B,58B,10B,72B,44B,26B,18B,20B,32B,54B,86B,28B,80B,42B,14B,96B,88B,90B,2B,24B,56B,98B,50B,12B,84B,66B,58B,60B,72B,94B,26B,68B,20B,82B,54B,36B,28B,30B,42B,64B,96B,38B,90B,52B,24B,6B,98B,0B,12B,34B,66B,8B,60B,22B,94B,76B,68B,70B,82B,4B,36B,78B,30B,92B,64B,46B,38B,40B,52B,74B,6B,48B,0B,62B,34B,16B,8B,10B,22B,44B,76B,18B,70B,32B,4B,86B,78B,80B,92B,14B,46B,88B,40B,2B,74B,56B,48B,50B,62B,84B,16B,58B,10B,72B,44B,26B,18B,20B,32B,54B,86B,28B,80B,42B,14B,96B,88B,90B,2B,24B,56B,98B,50B,12B,84B,66B,58B,60B,72B,94B,26B,68B,20B,82B,54B,36B,28B,30B,42B,64B,96B,38B,90B,52B,24B,6B,98B,0B,12B,34B,66B,8B,60B,22B,94B,76B,68B,70B,82B,4B,36B,78B,30B,92B,64B,46B,38B,40B,52B,74B,6B,48B,0B,62B,34B,16B,8B,10B,22B,44B,76B,18B,70B,32B,4B,86B,78B,80B,92B,14B,46B,88B,40B,2B,74B,56B,48B,50B,62B,84B,16B,58B,10B,72B,44B,26B,18B,20B,32B,54B,86B,28B,80B,42B,14B,96B,88B,90B,2B,24B,56B,98B,50B,12B,84B,66B,58B,60B,72B,94B,26B,68B,20B,82B,54B,36B,28B,30B,42B,64B,96B,38B,90B,52B,24B,6B,98B,0B,12B,34B,66B,8B,60B,22B,94B,76B,68B,70B,82B,4B,36B,78B,30B,92B,64B,46B,38B,40B,52B,74B,6B,48B,0B,62B,34B,16B,8B,10B,22B,44B,76B,18B,70B,32B,4B,86B,78B,80B,92B,14B,46B,88B,40B,2B,74B,56B,48B,50B,62B,84B,16B,58B,10B,72B,44B,26B,18B,20B,32B,54B,86B,28B,80B,42B,14B,96B,88B,90B,2B,24B,56B,98B,50B,12B,84B,66B,58B,60B,72B,94B,26B,68B,20B,82B,54B,36B,28B,30B,42B,64B,96B,38B,90B,52B,24B,6B,98B,0B,12B,34B,66B,8B,60B,22B,94B,76B,68B,70B,82B,4B,36B,78B,30B,92B,64B,46B,38B,40B,52B,74B,6B,48B],doubleTest:0.4931287132D}` {
		t.Fatalf("decode to SNBT error: get %s", snbt)
	}
}
